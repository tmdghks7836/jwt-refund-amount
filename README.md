# szs 유저 환급액 조회 API

------------
#  dependencies
  + lombok
  + jpa
  + spring-boot-starter-test
  + querydsl-jpa
  + springfox-swagger
  + h2database
  + mapstruct
  + spring-security
  + embedded-redis (refresh token 저장)
  + retrofit2
  + okhttp3:logging-interceptor (retrofit 요청 시 로그 확인)
------------

# swagger API

+  /swagger-ui/index.html

###  SzsMemberController (유저 환급액 조회)

  + POST /szs/login 유저 로그인
  + GET /szs/me 내정보 보기
  + GET /szs/refund 유저 환급액 계산 정보 조회
  + POST /szs/scrap 유저 정보 스크랩
  + POST /szs/signup 회원가입
  + GET /szs/token/re-issuance 액세스 토큰 재발급


### [요건]

  #### JWT 인증
  
  + 1. aceess token이 만료되면 httponly로 저장된 cookie로 재발급 요청합니다. 
  + 2.    

  ```
   
     
  ```
------------
# 주관식 문제 

## 1. 테스트코드 작성시 setup해야 할 데이터가 대용량이라면 어떤방식으로 테스트코드를 작성할지 서술해주세요.
 
  + 이러쿵저러쿵
--- 
## 2. 이벤트 드리븐 기반으로 서비스를 만들 때 이벤트를 구성하는 방식과 실패 처리하는 방식에 대해 서술해 주세요.
  #### apache kafka는 서비스간 메세지 브로커역할을 하고, 이벤트를 발행-구독하는 형식으로 구성되어있습니다. 또한 각 서비스는 구독한 이벤트에 대해 소비자(consumer) 역할을 합니다.
  #### 기존의 모놀리식구성에서의 트랜잭션 관리는 하나의 DBMS안에서 관리되었지만 이벤트 드리븐 기반 서비스는 어플리케이션 레벨에서 관리됩니다.  
  #### 각 서비스는 트랜잭션 실패에 대한 보상 트랜잭션(rollback을 하기 위함)을 각 서비스간 메세지 브로커에 관심사로 구독하고 있으며 이벤트 발생 시 rollback처리합니다. 
---
## 3. MSA 구성하는 방식에는 어떤 것들이 있고, 그중 선택하신다면 어떤 방식을 선택하실건가요?
  
  MSA는 서비스, DB가 분산되어있어 api로만 통신하여 트랜잭션 관리가 모놀리식(모든 서비스가 하나로 뭉쳐진 어플리케이션) 구성보다 어려운 것으로 알고있습니다. 
  그래서 생겨난 아키텍쳐 2가지를 찾아보았습니다. 
  
  ###  2Phase Commit 방식.
   #####  Coordinator에게 트랜잭션 관리를 맡겨 운영합니다.
   #####  투표단계, 커밋단계 둘로 구성되어 변경사항 요청을 반영합니다. 
    
   #### 투표단계   
    - 서비스 간 상태 변경 가능여부에 대해 투표하고 해당 Row에 lock을 잡습니다. 
    - 투표 결과 모두 가능한 상황이면 데이터 변경. 서비스 하나라도 변경 불가라면 트랜잭션을 중단합니다.
    - 변경은 하였지만 아직 반영 결과에 lock이 잡힌 상태입니다. 
 
   #### 커밋단계
    - 투표 완료 후 Coordinator가 Commit 메시지를 각 서비스로 전달합니다.
    - 각 서비스에서 데이터 변경을 반영합니다. 하지만 모든 서비스가 동시간대에 데이터 반영이 되지는 않습니다.
    - 그래서 트랜잭션의 기간이 길어지는만큼 대기시간이 길어지므로 사이클이 짧은 서비스에 사용하는 것을 권장합니다. 
    - 또한 기능이 많아질 수록 coordinator혼자 가지는 관리책임도 늘어나 서비스간 결합도가 강해집니다.
  
  ### saga패턴 방식.
   #### 서비스간 메세지 브로커로 데이터를 송수신하는 방식입니다.  
   #### 메세지 브로커는 대표적으로 kafka가 있으며 [producer - consumer] 로 구성되어 있습니다. 
   #### 트랜잭션을 병렬처리가 아닌 열로 이어져있으며 하나의 서비스 검증 성공 후 트랜잭션을 이어 다음 서비스로 이동하는 것이 특징입니다.
   #### 트랜잭션 실패시 backward/forward recovery 방식 두가지가 있습니다.
   
   #### backward recovery
    -  방식은 트랜잭션 실패 시 이전에 커밋된 트랜잭션을 모두 rollback시킵니다. 
    -  보상 트랜잭션을 통한 rollback을 합니다. 
    -  메세지 브로커는 보상 트랜잭션 데이터들 관리하며 그 이벤트를 구독하고 있는 서비스가 처리합니다. 
   #### backward recovery
    -  반면에 forward recovery 방식은 실패가 발생한 지점에서부터 충분한 정보를 유지하고 계속 앞으로 나아가 처리하는 방식입니다.
 
   
 ##### 결론은? 
 #####  저는 MSA를 통해 각 서비스팀이 책임을 나누어 가지게 될 수 있다는 점이 장점이라고 생각합니다. 
 #####  MSA의 방향성을 최대한 잘 살린 아키텍처라고 생각하는 saga패턴 방식을 선택할 것 같습니다.
   
---
## 4. 외부 의존성이 높은 서비스를 만들 때 고려해야 할 사항이 무엇인지 서술해 주세요.
  ##### 외부 api 서비스를 갑자기 중단해버리면 그에 맞게 대응하기 어렵거나, 대처시간이 오래걸릴 수 있습니다.
  ##### 크롤링 기능이 있다면 외부 서비스의 html폼 구성 변경으로 인한 오류가 생길 수 있으며 작업을 그에 맞게 다시 해야할 수 있습니다.
  ##### 통합테스트 시 의존성을 가지고 있는 서비스들을 모두 확인해야 하며 각 서비스간의 조정이 필요합니다. 
  
---
#### 5. 일정이 촉박한 프로젝트 진행 시 코드 컨벤션에 맞춰 개발할 것인지?
  
---
#### 6. 민감정보 암호화 알고리즘에는 어떤것들이 있고, 그중 선택하신다면 어떤것들을 선택하실건가요? 그 이유는?

  ##### 대칭, 비대칭 알고리즘이 있는 것으로 알고있습니다. 
  ##### 외부와 주기적으로 주고 받는 데이터는 https 에서 사용하는 것과 같은 비대칭 알고리즘을 사용할 것이고, 
  ##### 서비스 내에서만 관리되는 데이터는 관리의 편의성을 위해 대칭키 암호화 방식을 사용할 것입니다. 
------------
  
  
  
  
  
  
  
